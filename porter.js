// Generated by CoffeeScript 1.6.3
(function() {
  var PIDPATH, PORT, SECRET, authed, butler, checkPort, checkin, cleanup, droneName, fs, getRoutingTable, http, listen, net, nginx, path, portfinder, router, server, spawn, spawnNginx, upnode, _ref;

  upnode = require('upnode');

  portfinder = require('portfinder');

  net = require('net');

  http = require('http');

  path = require('path');

  fs = require('fs');

  spawn = require('child_process').spawn;

  router = require('./lib/router');

  PORT = 7004;

  SECRET = (_ref = process.env.PORTER_PASS) != null ? _ref : 'o87asdoa87sa';

  PIDPATH = path.resolve(__dirname, '..', '..', 'pids');

  router.setPIDPATH = PIDPATH;

  try {
    fs.mkdirSync(PIDPATH);
  } catch (_error) {}

  nginx = null;

  cleanup = function(err) {
    if (nginx != null) {
      nginx.kill();
    }
    throw err;
  };

  butler = {
    host: process.env.BUTLER_HOST,
    port: process.env.BUTLER_PORT,
    secret: process.env.BUTLER_SECRET
  };

  droneName = process.env.DRONE_NAME;

  spawnNginx = function() {
    return fs.readFile(path.join(PIDPATH, 'porternginx.pid'), function(err, data) {
      var pid;
      if (typeof pid !== "undefined" && pid !== null) {
        pid = data.toString();
      }
      if (pid != null) {
        process.kill(pid);
      }
      nginx = spawn("nginx", ['-c', path.resolve(__dirname, 'nginx', 'nginx.conf')]);
      nginx.stdout.on('data', function(data) {
        return console.log("Stdout from nginx:", data.toString());
      });
      nginx.stderr.on('data', function(data) {
        return console.error("Stderr from nginx", data.toString());
      });
      nginx.on('close', function(code, signal) {
        console.log("nginx closed with code " + code + " and signal " + signal);
        return spawnNginx();
      });
      return nginx.on('error', function(err) {
        console.error('Error on nginx process', err);
        return spawnNginx();
      });
    });
  };

  getRoutingTable = function(remote) {
    var connection, opts;
    if (process.env.PORTER_TESTING) {
      return;
    }
    opts = {
      hostname: remote.host,
      port: remote.port,
      path: "/routingTable",
      auth: "porter:" + remote.secret
    };
    connection = http.get(opts, function(res) {
      var responseText;
      if (res.statusCode !== 200) {
        cleanup(new Error("Failed to get routing table, status: " + res.statusCode));
      }
      responseText = '';
      res.on('data', function(data) {
        return responseText += data.toString();
      });
      return res.on('end', function() {
        var routingTable;
        routingTable = JSON.parse(responseText);
        router.writeFile(routingTable, function(err) {
          if (err != null) {
            return cleanup(err);
          }
        });
        return this.socket.end();
      });
    }).on("error", function(e) {
      return cleanup(new Error(e));
    });
    return connection.on('socket', function(socket) {
      socket.setTimeout(10 * 1000);
      return socket.on('timeout', function() {
        return cleanup(new Error("getRoutingTable timeout"));
      });
    });
  };

  checkin = function(remote) {
    var connection, opts;
    if (process.env.PORTER_TESTING) {
      return;
    }
    opts = {
      hostname: remote.host,
      port: remote.port,
      path: "/checkin/" + droneName,
      auth: "porter:" + remote.secret
    };
    connection = http.get(opts, function(res) {
      if (res.statusCode !== 200) {
        cleanup(new Error("Checkin failed with status " + res.statusCode));
      }
      console.log("Checked in with " + remote.host + ":" + remote.port);
      return this.socket.end();
    }).on("error", function(e) {
      return cleanup(new Error(e));
    });
    return connection.on('socket', function(socket) {
      socket.setTimeout(10 * 1000);
      return socket.on('timeout', function() {
        return cleanup(new Error("Checkin timeout"));
      });
    });
  };

  listen = function() {
    server.listen(PORT);
    checkin(butler);
    getRoutingTable(butler);
    setInterval(function() {
      return checkin(butler);
    }, 60 * 1000);
    return router.writeFile({}, function(err) {
      if (err != null) {
        throw err;
      }
      return spawnNginx();
    });
  };

  authed = {
    port: function(cb) {
      return portfinder.getPort(function(err, port) {
        portfinder.basePort = port + 1;
        if (portfinder.basePort > 9000) {
          portfinder.basePort = 8000;
        }
        return cb(err, port);
      });
    },
    updateRouting: function(routes, cb) {
      return router.writeFile(routes, function(err) {
        if (err == null) {
          nginx.kill('SIGHUP');
        }
        return cb(err);
      });
    }
  };

  server = upnode(function(client, conn) {
    return this.auth = function(secret, cb) {
      if (secret === SECRET) {
        return cb(null, authed);
      }
      return cb('DENIED');
    };
  });

  checkPort = function() {
    var tester;
    tester = net.createServer();
    tester.on('error', function(error) {
      console.log("Porter already running?");
      return setTimeout(function() {
        return checkPort();
      }, 10 * 1000);
    });
    return tester.listen(PORT, function() {
      return tester.close(function() {
        return listen();
      });
    });
  };

  checkPort();

  console.log("Server listening on " + PORT);

  module.exports = {
    authed: authed
  };

}).call(this);
